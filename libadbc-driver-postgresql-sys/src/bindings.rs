/* automatically generated by rust-bindgen 0.66.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ARROW_FLAG_DICTIONARY_ORDERED: u32 = 1;
pub const ARROW_FLAG_NULLABLE: u32 = 2;
pub const ARROW_FLAG_MAP_KEYS_SORTED: u32 = 4;
pub const ADBC_STATUS_OK: u32 = 0;
pub const ADBC_STATUS_UNKNOWN: u32 = 1;
pub const ADBC_STATUS_NOT_IMPLEMENTED: u32 = 2;
pub const ADBC_STATUS_NOT_FOUND: u32 = 3;
pub const ADBC_STATUS_ALREADY_EXISTS: u32 = 4;
pub const ADBC_STATUS_INVALID_ARGUMENT: u32 = 5;
pub const ADBC_STATUS_INVALID_STATE: u32 = 6;
pub const ADBC_STATUS_INVALID_DATA: u32 = 7;
pub const ADBC_STATUS_INTEGRITY: u32 = 8;
pub const ADBC_STATUS_INTERNAL: u32 = 9;
pub const ADBC_STATUS_IO: u32 = 10;
pub const ADBC_STATUS_CANCELLED: u32 = 11;
pub const ADBC_STATUS_TIMEOUT: u32 = 12;
pub const ADBC_STATUS_UNAUTHENTICATED: u32 = 13;
pub const ADBC_STATUS_UNAUTHORIZED: u32 = 14;
pub const ADBC_ERROR_VENDOR_CODE_PRIVATE_DATA: i32 = -2147483648;
pub const ADBC_VERSION_1_0_0: u32 = 1000000;
pub const ADBC_VERSION_1_1_0: u32 = 1001000;
pub const ADBC_OPTION_VALUE_ENABLED: &[u8; 5] = b"true\0";
pub const ADBC_OPTION_VALUE_DISABLED: &[u8; 6] = b"false\0";
pub const ADBC_OPTION_URI: &[u8; 4] = b"uri\0";
pub const ADBC_OPTION_USERNAME: &[u8; 9] = b"username\0";
pub const ADBC_OPTION_PASSWORD: &[u8; 9] = b"password\0";
pub const ADBC_INFO_VENDOR_NAME: u32 = 0;
pub const ADBC_INFO_VENDOR_VERSION: u32 = 1;
pub const ADBC_INFO_VENDOR_ARROW_VERSION: u32 = 2;
pub const ADBC_INFO_DRIVER_NAME: u32 = 100;
pub const ADBC_INFO_DRIVER_VERSION: u32 = 101;
pub const ADBC_INFO_DRIVER_ARROW_VERSION: u32 = 102;
pub const ADBC_INFO_DRIVER_ADBC_VERSION: u32 = 103;
pub const ADBC_OBJECT_DEPTH_ALL: u32 = 0;
pub const ADBC_OBJECT_DEPTH_CATALOGS: u32 = 1;
pub const ADBC_OBJECT_DEPTH_DB_SCHEMAS: u32 = 2;
pub const ADBC_OBJECT_DEPTH_TABLES: u32 = 3;
pub const ADBC_OBJECT_DEPTH_COLUMNS: u32 = 0;
pub const ADBC_STATISTIC_AVERAGE_BYTE_WIDTH_KEY: u32 = 0;
pub const ADBC_STATISTIC_AVERAGE_BYTE_WIDTH_NAME: &[u8; 26] = b"adbc.statistic.byte_width\0";
pub const ADBC_STATISTIC_DISTINCT_COUNT_KEY: u32 = 1;
pub const ADBC_STATISTIC_DISTINCT_COUNT_NAME: &[u8; 30] = b"adbc.statistic.distinct_count\0";
pub const ADBC_STATISTIC_MAX_BYTE_WIDTH_KEY: u32 = 2;
pub const ADBC_STATISTIC_MAX_BYTE_WIDTH_NAME: &[u8; 26] = b"adbc.statistic.byte_width\0";
pub const ADBC_STATISTIC_MAX_VALUE_KEY: u32 = 3;
pub const ADBC_STATISTIC_MAX_VALUE_NAME: &[u8; 26] = b"adbc.statistic.byte_width\0";
pub const ADBC_STATISTIC_MIN_VALUE_KEY: u32 = 4;
pub const ADBC_STATISTIC_MIN_VALUE_NAME: &[u8; 26] = b"adbc.statistic.byte_width\0";
pub const ADBC_STATISTIC_NULL_COUNT_KEY: u32 = 5;
pub const ADBC_STATISTIC_NULL_COUNT_NAME: &[u8; 26] = b"adbc.statistic.null_count\0";
pub const ADBC_STATISTIC_ROW_COUNT_KEY: u32 = 6;
pub const ADBC_STATISTIC_ROW_COUNT_NAME: &[u8; 25] = b"adbc.statistic.row_count\0";
pub const ADBC_CONNECTION_OPTION_AUTOCOMMIT: &[u8; 27] = b"adbc.connection.autocommit\0";
pub const ADBC_CONNECTION_OPTION_READ_ONLY: &[u8; 25] = b"adbc.connection.readonly\0";
pub const ADBC_CONNECTION_OPTION_CURRENT_CATALOG: &[u8; 24] = b"adbc.connection.catalog\0";
pub const ADBC_CONNECTION_OPTION_CURRENT_DB_SCHEMA: &[u8; 26] = b"adbc.connection.db_schema\0";
pub const ADBC_STATEMENT_OPTION_INCREMENTAL: &[u8; 32] = b"adbc.statement.exec.incremental\0";
pub const ADBC_STATEMENT_OPTION_PROGRESS: &[u8; 29] = b"adbc.statement.exec.progress\0";
pub const ADBC_STATEMENT_OPTION_MAX_PROGRESS: &[u8; 33] = b"adbc.statement.exec.max_progress\0";
pub const ADBC_CONNECTION_OPTION_ISOLATION_LEVEL: &[u8; 44] =
    b"adbc.connection.transaction.isolation_level\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_DEFAULT: &[u8; 46] =
    b"adbc.connection.transaction.isolation.default\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_READ_UNCOMMITTED: &[u8; 55] =
    b"adbc.connection.transaction.isolation.read_uncommitted\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_READ_COMMITTED: &[u8; 53] =
    b"adbc.connection.transaction.isolation.read_committed\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_REPEATABLE_READ: &[u8; 54] =
    b"adbc.connection.transaction.isolation.repeatable_read\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_SNAPSHOT: &[u8; 47] =
    b"adbc.connection.transaction.isolation.snapshot\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_SERIALIZABLE: &[u8; 51] =
    b"adbc.connection.transaction.isolation.serializable\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_LINEARIZABLE: &[u8; 51] =
    b"adbc.connection.transaction.isolation.linearizable\0";
pub const ADBC_INGEST_OPTION_TARGET_TABLE: &[u8; 25] = b"adbc.ingest.target_table\0";
pub const ADBC_INGEST_OPTION_MODE: &[u8; 17] = b"adbc.ingest.mode\0";
pub const ADBC_INGEST_OPTION_MODE_CREATE: &[u8; 24] = b"adbc.ingest.mode.create\0";
pub const ADBC_INGEST_OPTION_MODE_APPEND: &[u8; 24] = b"adbc.ingest.mode.append\0";
pub const ADBC_INGEST_OPTION_MODE_REPLACE: &[u8; 25] = b"adbc.ingest.mode.replace\0";
pub const ADBC_INGEST_OPTION_MODE_CREATE_APPEND: &[u8; 31] = b"adbc.ingest.mode.create_append\0";
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowSchema {
    pub format: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub metadata: *const ::std::os::raw::c_char,
    pub flags: i64,
    pub n_children: i64,
    pub children: *mut *mut ArrowSchema,
    pub dictionary: *mut ArrowSchema,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowSchema)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowSchema() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowSchema> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowSchema>(),
        72usize,
        concat!("Size of: ", stringify!(ArrowSchema))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowSchema>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowSchema))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(n_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(private_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowArray {
    pub length: i64,
    pub null_count: i64,
    pub offset: i64,
    pub n_buffers: i64,
    pub n_children: i64,
    pub buffers: *mut *const ::std::os::raw::c_void,
    pub children: *mut *mut ArrowArray,
    pub dictionary: *mut ArrowArray,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowArray)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowArray() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowArray>(),
        80usize,
        concat!("Size of: ", stringify!(ArrowArray))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowArray>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).null_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(null_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_buffers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(n_buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(n_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffers) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(private_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowArrayStream {
    pub get_schema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ArrowArrayStream,
            out: *mut ArrowSchema,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ArrowArrayStream,
            out: *mut ArrowArray,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_last_error: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ArrowArrayStream) -> *const ::std::os::raw::c_char,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowArrayStream)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowArrayStream() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowArrayStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowArrayStream>(),
        40usize,
        concat!("Size of: ", stringify!(ArrowArrayStream))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowArrayStream>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowArrayStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_schema) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_schema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_last_error) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_last_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(private_data)
        )
    );
}
#[doc = " \\brief Error codes for operations that may fail."]
pub type AdbcStatusCode = u8;
#[doc = " \\brief A detailed error message for an operation.\n\n The caller must zero-initialize this struct (clarified in ADBC 1.1.0).\n\n The structure was extended in ADBC 1.1.0.  Drivers and clients using ADBC\n 1.0.0 will not have the private_data or private_driver fields.  Drivers\n should read/write these fields if and only if vendor_code is equal to\n ADBC_ERROR_VENDOR_CODE_PRIVATE_DATA.  Clients are required to initialize\n this struct to avoid the possibility of uninitialized values confusing the\n driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcError {
    #[doc = " \\brief The error message."]
    pub message: *mut ::std::os::raw::c_char,
    #[doc = " \\brief A vendor-specific error code, if applicable."]
    pub vendor_code: i32,
    #[doc = " \\brief A SQLSTATE error code, if provided, as defined by the\n   SQL:2003 standard.  If not set, it should be set to\n   \"\\0\\0\\0\\0\\0\"."]
    pub sqlstate: [::std::os::raw::c_char; 5usize],
    #[doc = " \\brief Release the contained error.\n\n Unlike other structures, this is an embedded callback to make it\n easier for the driver manager and driver to cooperate."]
    pub release: ::std::option::Option<unsafe extern "C" fn(error: *mut AdbcError)>,
    #[doc = " \\brief Opaque implementation-defined state.\n\n This field may not be used unless vendor_code is\n ADBC_ERROR_VENDOR_CODE_PRIVATE_DATA.  If present, this field is NULLPTR\n iff the error is unintialized/freed.\n\n \\since ADBC API revision 1.1.0"]
    pub private_data: *mut ::std::os::raw::c_void,
    #[doc = " \\brief The associated driver (used by the driver manager to help\n   track state).\n\n This field may not be used unless vendor_code is\n ADBC_ERROR_VENDOR_CODE_PRIVATE_DATA.\n\n \\since ADBC API revision 1.1.0"]
    pub private_driver: *mut AdbcDriver,
}
#[test]
fn bindgen_test_layout_AdbcError() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcError>(),
        48usize,
        concat!("Size of: ", stringify!(AdbcError))
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcError>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(vendor_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sqlstate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(sqlstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_driver) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(private_driver)
        )
    );
}
#[doc = " \\brief Extra key-value metadata for an error.\n\n The fields here are owned by the driver and should not be freed.  The\n fields here are invalidated when the release callback in AdbcError is\n called.\n\n \\since ADBC API revision 1.1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcErrorDetail {
    #[doc = " \\brief The metadata key."]
    pub key: *const ::std::os::raw::c_char,
    #[doc = " \\brief The binary metadata value."]
    pub value: *const u8,
    #[doc = " \\brief The length of the metadata value."]
    pub value_length: usize,
}
#[test]
fn bindgen_test_layout_AdbcErrorDetail() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcErrorDetail> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcErrorDetail>(),
        24usize,
        concat!("Size of: ", stringify!(AdbcErrorDetail))
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcErrorDetail>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcErrorDetail))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcErrorDetail),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcErrorDetail),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcErrorDetail),
            "::",
            stringify!(value_length)
        )
    );
}
extern "C" {
    #[doc = " \\brief Get the number of metadata values available in an error.\n\n \\since ADBC API revision 1.1.0"]
    pub fn AdbcErrorGetDetailCount(error: *const AdbcError) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get a metadata value in an error by index.\n\n If index is invalid, returns an AdbcErrorDetail initialized with NULL/0\n fields.\n\n \\since ADBC API revision 1.1.0"]
    pub fn AdbcErrorGetDetail(
        error: *const AdbcError,
        index: ::std::os::raw::c_int,
    ) -> AdbcErrorDetail;
}
extern "C" {
    #[doc = " \\brief Get an ADBC error from an ArrowArrayStream created by a driver.\n\n This allows retrieving error details and other metadata that would\n normally be suppressed by the Arrow C Stream Interface.\n\n The caller MUST NOT release the error; it is managed by the release\n callback in the stream itself.\n\n \\param[in] stream The stream to query.\n \\param[out] status The ADBC status code, or ADBC_STATUS_OK if there is no\n   error.  Not written to if the stream does not contain an ADBC error or\n   if the pointer is NULL.\n \\return NULL if not supported.\n \\since ADBC API revision 1.1.0"]
    pub fn AdbcErrorFromArrayStream(
        stream: *mut ArrowArrayStream,
        status: *mut AdbcStatusCode,
    ) -> *const AdbcError;
}
#[doc = " \\brief An instance of a database.\n\n Must be kept alive as long as any connections exist."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcDatabase {
    #[doc = " \\brief Opaque implementation-defined state.\n This field is NULLPTR iff the connection is unintialized/freed."]
    pub private_data: *mut ::std::os::raw::c_void,
    #[doc = " \\brief The associated driver (used by the driver manager to help\n   track state)."]
    pub private_driver: *mut AdbcDriver,
}
#[test]
fn bindgen_test_layout_AdbcDatabase() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcDatabase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcDatabase>(),
        16usize,
        concat!("Size of: ", stringify!(AdbcDatabase))
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcDatabase>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcDatabase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDatabase),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_driver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDatabase),
            "::",
            stringify!(private_driver)
        )
    );
}
#[doc = " \\brief An active database connection.\n\n Provides methods for query execution, managing prepared\n statements, using transactions, and so on.\n\n Connections are not required to be thread-safe, but they can be\n used from multiple threads so long as clients take care to\n serialize accesses to a connection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcConnection {
    #[doc = " \\brief Opaque implementation-defined state.\n This field is NULLPTR iff the connection is unintialized/freed."]
    pub private_data: *mut ::std::os::raw::c_void,
    #[doc = " \\brief The associated driver (used by the driver manager to help\n   track state)."]
    pub private_driver: *mut AdbcDriver,
}
#[test]
fn bindgen_test_layout_AdbcConnection() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcConnection>(),
        16usize,
        concat!("Size of: ", stringify!(AdbcConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcConnection),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_driver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcConnection),
            "::",
            stringify!(private_driver)
        )
    );
}
#[doc = " \\brief A container for all state needed to execute a database\n query, such as the query itself, parameters for prepared\n statements, driver parameters, etc.\n\n Statements may represent queries or prepared statements.\n\n Statements may be used multiple times and can be reconfigured\n (e.g. they can be reused to execute multiple different queries).\n However, executing a statement (and changing certain other state)\n will invalidate result sets obtained prior to that execution.\n\n Multiple statements may be created from a single connection.\n However, the driver may block or error if they are used\n concurrently (whether from a single thread or multiple threads).\n\n Statements are not required to be thread-safe, but they can be\n used from multiple threads so long as clients take care to\n serialize accesses to a statement."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcStatement {
    #[doc = " \\brief Opaque implementation-defined state.\n This field is NULLPTR iff the connection is unintialized/freed."]
    pub private_data: *mut ::std::os::raw::c_void,
    #[doc = " \\brief The associated driver (used by the driver manager to help\n   track state)."]
    pub private_driver: *mut AdbcDriver,
}
#[test]
fn bindgen_test_layout_AdbcStatement() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcStatement> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcStatement>(),
        16usize,
        concat!("Size of: ", stringify!(AdbcStatement))
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcStatement>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcStatement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcStatement),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_driver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcStatement),
            "::",
            stringify!(private_driver)
        )
    );
}
#[doc = " \\brief The partitions of a distributed/partitioned result set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcPartitions {
    #[doc = " \\brief The number of partitions."]
    pub num_partitions: usize,
    #[doc = " \\brief The partitions of the result set, where each entry (up to\n   num_partitions entries) is an opaque identifier that can be\n   passed to AdbcConnectionReadPartition."]
    pub partitions: *mut *const u8,
    #[doc = " \\brief The length of each corresponding entry in partitions."]
    pub partition_lengths: *const usize,
    #[doc = " \\brief Opaque implementation-defined state.\n This field is NULLPTR iff the connection is unintialized/freed."]
    pub private_data: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Release the contained partitions.\n\n Unlike other structures, this is an embedded callback to make it\n easier for the driver manager and driver to cooperate."]
    pub release: ::std::option::Option<unsafe extern "C" fn(partitions: *mut AdbcPartitions)>,
}
#[test]
fn bindgen_test_layout_AdbcPartitions() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcPartitions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcPartitions>(),
        40usize,
        concat!("Size of: ", stringify!(AdbcPartitions))
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcPartitions>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcPartitions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_partitions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(num_partitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partitions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(partitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partition_lengths) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(partition_lengths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " \\brief An instance of an initialized database driver.\n\n This provides a common interface for vendor-specific driver\n initialization routines. Drivers should populate this struct, and\n applications can call ADBC functions through this struct, without\n worrying about multiple definitions of the same symbol."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcDriver {
    #[doc = " \\brief Opaque driver-defined state.\n This field is NULL if the driver is unintialized/freed (but\n it need not have a value even if the driver is initialized)."]
    pub private_data: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Opaque driver manager-defined state.\n This field is NULL if the driver is unintialized/freed (but\n it need not have a value even if the driver is initialized)."]
    pub private_manager: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Release the driver and perform any cleanup.\n\n This is an embedded callback to make it easier for the driver\n manager and driver to cooperate."]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(driver: *mut AdbcDriver, error: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub DatabaseInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcDatabase, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub DatabaseNew: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcDatabase, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub DatabaseSetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseRelease: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcDatabase, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub ConnectionCommit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcConnection, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub ConnectionGetInfo: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const u32,
            arg3: usize,
            arg4: *mut ArrowArrayStream,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetObjects: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: *const ::std::os::raw::c_char,
            arg6: *mut *const ::std::os::raw::c_char,
            arg7: *const ::std::os::raw::c_char,
            arg8: *mut ArrowArrayStream,
            arg9: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetTableSchema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: *mut ArrowSchema,
            arg6: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetTableTypes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut ArrowArrayStream,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionInit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcDatabase,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionNew: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcConnection, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub ConnectionSetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionReadPartition: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const u8,
            arg3: usize,
            arg4: *mut ArrowArrayStream,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionRelease: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcConnection, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub ConnectionRollback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcConnection, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub StatementBind: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowArray,
            arg3: *mut ArrowSchema,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementBindStream: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowArrayStream,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementExecuteQuery: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowArrayStream,
            arg3: *mut i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementExecutePartitions: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowSchema,
            arg3: *mut AdbcPartitions,
            arg4: *mut i64,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetParameterSchema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowSchema,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementNew: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcStatement,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementPrepare: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcStatement, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub StatementRelease: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcStatement, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub StatementSetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetSqlQuery: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetSubstraitPlan: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const u8,
            arg3: usize,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    #[doc = " \\defgroup adbc-1.1.0 ADBC API Revision 1.1.0\n\n Functions added in ADBC 1.1.0.  For backwards compatibility,\n these members must not be accessed unless the version passed to\n the AdbcDriverInitFunc is greater than or equal to\n ADBC_VERSION_1_1_0.\n\n For a 1.0.0 driver being loaded by a 1.1.0 driver manager: the\n 1.1.0 manager will allocate the new, expanded AdbcDriver struct\n and attempt to have the driver initialize it with\n ADBC_VERSION_1_1_0.  This must return an error, after which the\n driver will try again with ADBC_VERSION_1_0_0.  The driver must\n not access the new fields, which will carry undefined values.\n\n For a 1.1.0 driver being loaded by a 1.0.0 driver manager: the\n 1.0.0 manager will allocate the old AdbcDriver struct and\n attempt to have the driver initialize it with\n ADBC_VERSION_1_0_0.  The driver must not access the new fields,\n and should initialize the old fields.\n\n @{"]
    pub ErrorGetDetailCount: ::std::option::Option<
        unsafe extern "C" fn(error: *const AdbcError) -> ::std::os::raw::c_int,
    >,
    pub ErrorGetDetail: ::std::option::Option<
        unsafe extern "C" fn(
            error: *const AdbcError,
            index: ::std::os::raw::c_int,
        ) -> AdbcErrorDetail,
    >,
    pub ErrorFromArrayStream: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut ArrowArrayStream,
            status: *mut AdbcStatusCode,
        ) -> *const AdbcError,
    >,
    pub DatabaseGetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseGetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut u8,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseGetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseGetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseSetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const u8,
            arg4: usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseSetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseSetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionCancel: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcConnection, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub ConnectionGetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut u8,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetStatistics: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: ::std::os::raw::c_char,
            arg6: *mut ArrowArrayStream,
            arg7: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetStatisticNames: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut ArrowArrayStream,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionSetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const u8,
            arg4: usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionSetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionSetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementCancel: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AdbcStatement, arg2: *mut AdbcError) -> AdbcStatusCode,
    >,
    pub StatementExecuteSchema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowSchema,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut u8,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const u8,
            arg4: usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
}
#[test]
fn bindgen_test_layout_AdbcDriver() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcDriver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcDriver>(),
        464usize,
        concat!("Size of: ", stringify!(AdbcDriver))
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcDriver>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcDriver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_manager) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(private_manager)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseInit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseInit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseNew) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseNew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseSetOption) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseSetOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseRelease) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseRelease)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionCommit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionCommit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetInfo) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetObjects) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetObjects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetTableSchema) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetTableSchema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetTableTypes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetTableTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionInit) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionInit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionNew) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionNew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionSetOption) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionSetOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionReadPartition) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionReadPartition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionRelease) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionRelease)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionRollback) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionRollback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementBind) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementBind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementBindStream) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementBindStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementExecuteQuery) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementExecuteQuery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementExecutePartitions) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementExecutePartitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementGetParameterSchema) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetParameterSchema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementNew) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementNew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementPrepare) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementPrepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementRelease) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementRelease)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementSetOption) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementSetSqlQuery) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetSqlQuery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementSetSubstraitPlan) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetSubstraitPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorGetDetailCount) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ErrorGetDetailCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorGetDetail) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ErrorGetDetail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorFromArrayStream) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ErrorFromArrayStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseGetOption) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseGetOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseGetOptionBytes) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseGetOptionBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseGetOptionDouble) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseGetOptionDouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseGetOptionInt) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseGetOptionInt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseSetOptionBytes) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseSetOptionBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseSetOptionDouble) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseSetOptionDouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseSetOptionInt) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseSetOptionInt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionCancel) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionCancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetOption) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetOptionBytes) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetOptionBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetOptionDouble) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetOptionDouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetOptionInt) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetOptionInt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetStatistics) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetStatistics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionGetStatisticNames) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetStatisticNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionSetOptionBytes) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionSetOptionBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionSetOptionDouble) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionSetOptionDouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionSetOptionInt) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionSetOptionInt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementCancel) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementCancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementExecuteSchema) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementExecuteSchema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementGetOption) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementGetOptionBytes) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetOptionBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementGetOptionDouble) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetOptionDouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementGetOptionInt) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetOptionInt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementSetOptionBytes) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetOptionBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementSetOptionDouble) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetOptionDouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementSetOptionInt) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetOptionInt)
        )
    );
}
extern "C" {
    #[doc = " \\brief Allocate a new (but uninitialized) database.\n\n Callers pass in a zero-initialized AdbcDatabase.\n\n Drivers should allocate their internal data structure and set the private_data\n field to point to the newly allocated struct. This struct should be released\n when AdbcDatabaseRelease is called."]
    pub fn AdbcDatabaseNew(database: *mut AdbcDatabase, error: *mut AdbcError) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a string option of the database.\n\n This must always be thread-safe (other operations are not), though\n given the semantics here, it is not recommended to call GetOption\n concurrently with itself.\n\n length must be provided and must be the size of the buffer pointed\n to by value.  If there is sufficient space, the driver will copy\n the option value (including the null terminator) to buffer and set\n length to the size of the actual value.  If the buffer is too\n small, no data will be written and length will be set to the\n required length.\n\n In other words:\n\n - If output length <= input length, value will contain a value\n   with length bytes.\n - If output length > input length, nothing has been written to\n   value.\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] database The database.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[in,out] length The length of value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcDatabaseGetOption(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a bytestring option of the database.\n\n This must always be thread-safe (other operations are not), though\n given the semantics here, it is not recommended to call\n GetOptionBytes concurrently with itself.\n\n length must be provided and must be the size of the buffer pointed\n to by value.  If there is sufficient space, the driver will copy\n the option value to buffer and set length to the size of the\n actual value.  If the buffer is too small, no data will be written\n and length will be set to the required length.\n\n In other words:\n\n - If output length <= input length, value will contain a value\n   with length bytes.\n - If output length > input length, nothing has been written to\n   value.\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] database The database.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[in,out] length The option value length.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcDatabaseGetOptionBytes(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *mut u8,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a double option of the database.\n\n This must always be thread-safe (other operations are not).\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the double\n representation of an integer option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] database The database.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcDatabaseGetOptionDouble(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get an integer option of the database.\n\n This must always be thread-safe (other operations are not).\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the integer\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] database The database.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcDatabaseGetOptionInt(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a char* option.\n\n Options may be set before AdbcDatabaseInit.  Some drivers may\n support setting options after initialization as well.\n\n \\param[in] database The database.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcDatabaseSetOption(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a bytestring option on a database.\n\n \\since ADBC API revision 1.1.0\n \\param[in] database The database.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[in] length The option value length.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcDatabaseSetOptionBytes(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *const u8,
        length: usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a double option on a database.\n\n \\since ADBC API revision 1.1.0\n \\param[in] database The database.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcDatabaseSetOptionDouble(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set an integer option on a database.\n\n \\since ADBC API revision 1.1.0\n \\param[in] database The database.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcDatabaseSetOptionInt(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Finish setting options and initialize the database.\n\n Some drivers may support setting options after initialization\n as well."]
    pub fn AdbcDatabaseInit(database: *mut AdbcDatabase, error: *mut AdbcError) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Destroy this database. No connections may exist.\n \\param[in] database The database to release.\n \\param[out] error An optional location to return an error\n   message if necessary."]
    pub fn AdbcDatabaseRelease(
        database: *mut AdbcDatabase,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Allocate a new (but uninitialized) connection.\n\n Callers pass in a zero-initialized AdbcConnection.\n\n Drivers should allocate their internal data structure and set the private_data\n field to point to the newly allocated struct. This struct should be released\n when AdbcConnectionRelease is called."]
    pub fn AdbcConnectionNew(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a char* option.\n\n Options may be set before AdbcConnectionInit.  Some drivers may\n support setting options after initialization as well.\n\n \\param[in] connection The database connection.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcConnectionSetOption(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a bytestring option on a connection.\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The connection.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[in] length The option value length.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcConnectionSetOptionBytes(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *const u8,
        length: usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set an integer option.\n\n Options may be set before AdbcConnectionInit.  Some drivers may\n support setting options after initialization as well.\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The database connection.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcConnectionSetOptionInt(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a double option.\n\n Options may be set before AdbcConnectionInit.  Some drivers may\n support setting options after initialization as well.\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The database connection.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcConnectionSetOptionDouble(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Finish setting options and initialize the connection.\n\n Some drivers may support setting options after initialization\n as well."]
    pub fn AdbcConnectionInit(
        connection: *mut AdbcConnection,
        database: *mut AdbcDatabase,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Destroy this connection.\n\n \\param[in] connection The connection to release.\n \\param[out] error An optional location to return an error\n   message if necessary."]
    pub fn AdbcConnectionRelease(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Cancel the in-progress operation on a connection.\n\n This can be called during AdbcConnectionGetObjects (or similar),\n or while consuming an ArrowArrayStream returned from such.\n Calling this function should make the other functions return\n ADBC_STATUS_CANCELLED (from ADBC functions) or ECANCELED (from\n methods of ArrowArrayStream).  (It is not guaranteed to, for\n instance, the result set may be buffered in memory already.)\n\n This must always be thread-safe (other operations are not).  It is\n not necessarily signal-safe.\n\n \\since ADBC API revision 1.1.0\n\n \\param[in] connection The connection to cancel.\n \\param[out] error An optional location to return an error\n   message if necessary.\n\n \\return ADBC_STATUS_INVALID_STATE if there is no operation to cancel.\n \\return ADBC_STATUS_UNKNOWN if the operation could not be cancelled."]
    pub fn AdbcConnectionCancel(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get metadata about the database/driver.\n\n The result is an Arrow dataset with the following schema:\n\n Field Name                  | Field Type\n ----------------------------|------------------------\n info_name                   | uint32 not null\n info_value                  | INFO_SCHEMA\n\n INFO_SCHEMA is a dense union with members:\n\n Field Name (Type Code)      | Field Type\n ----------------------------|------------------------\n string_value (0)            | utf8\n bool_value (1)              | bool\n int64_value (2)             | int64\n int32_bitmask (3)           | int32\n string_list (4)             | list<utf8>\n int32_to_int32_list_map (5) | map<int32, list<int32>>\n\n Each metadatum is identified by an integer code.  The recognized\n codes are defined as constants.  Codes [0, 10_000) are reserved\n for ADBC usage.  Drivers/vendors will ignore requests for\n unrecognized codes (the row will be omitted from the result).\n\n Since ADBC 1.1.0: the range [500, 1_000) is reserved for \"XDBC\"\n information, which is the same metadata provided by the same info\n code range in the Arrow Flight SQL GetSqlInfo RPC.\n\n \\param[in] connection The connection to query.\n \\param[in] info_codes A list of metadata codes to fetch, or NULL\n   to fetch all.\n \\param[in] info_codes_length The length of the info_codes\n   parameter.  Ignored if info_codes is NULL.\n \\param[out] out The result set.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcConnectionGetInfo(
        connection: *mut AdbcConnection,
        info_codes: *const u32,
        info_codes_length: usize,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a hierarchical view of all catalogs, database schemas,\n   tables, and columns.\n\n The result is an Arrow dataset with the following schema:\n\n | Field Name               | Field Type              |\n |--------------------------|-------------------------|\n | catalog_name             | utf8                    |\n | catalog_db_schemas       | list<DB_SCHEMA_SCHEMA>  |\n\n DB_SCHEMA_SCHEMA is a Struct with fields:\n\n | Field Name               | Field Type              |\n |--------------------------|-------------------------|\n | db_schema_name           | utf8                    |\n | db_schema_tables         | list<TABLE_SCHEMA>      |\n\n TABLE_SCHEMA is a Struct with fields:\n\n | Field Name               | Field Type              |\n |--------------------------|-------------------------|\n | table_name               | utf8 not null           |\n | table_type               | utf8 not null           |\n | table_columns            | list<COLUMN_SCHEMA>     |\n | table_constraints        | list<CONSTRAINT_SCHEMA> |\n\n COLUMN_SCHEMA is a Struct with fields:\n\n | Field Name               | Field Type              | Comments |\n |--------------------------|-------------------------|----------|\n | column_name              | utf8 not null           |          |\n | ordinal_position         | int32                   | (1)      |\n | remarks                  | utf8                    | (2)      |\n | xdbc_data_type           | int16                   | (3)      |\n | xdbc_type_name           | utf8                    | (3)      |\n | xdbc_column_size         | int32                   | (3)      |\n | xdbc_decimal_digits      | int16                   | (3)      |\n | xdbc_num_prec_radix      | int16                   | (3)      |\n | xdbc_nullable            | int16                   | (3)      |\n | xdbc_column_def          | utf8                    | (3)      |\n | xdbc_sql_data_type       | int16                   | (3)      |\n | xdbc_datetime_sub        | int16                   | (3)      |\n | xdbc_char_octet_length   | int32                   | (3)      |\n | xdbc_is_nullable         | utf8                    | (3)      |\n | xdbc_scope_catalog       | utf8                    | (3)      |\n | xdbc_scope_schema        | utf8                    | (3)      |\n | xdbc_scope_table         | utf8                    | (3)      |\n | xdbc_is_autoincrement    | bool                    | (3)      |\n | xdbc_is_generatedcolumn  | bool                    | (3)      |\n\n 1. The column's ordinal position in the table (starting from 1).\n 2. Database-specific description of the column.\n 3. Optional value.  Should be null if not supported by the driver.\n    xdbc_ values are meant to provide JDBC/ODBC-compatible metadata\n    in an agnostic manner.\n\n CONSTRAINT_SCHEMA is a Struct with fields:\n\n | Field Name               | Field Type              | Comments |\n |--------------------------|-------------------------|----------|\n | constraint_name          | utf8                    |          |\n | constraint_type          | utf8 not null           | (1)      |\n | constraint_column_names  | list<utf8> not null     | (2)      |\n | constraint_column_usage  | list<USAGE_SCHEMA>      | (3)      |\n\n 1. One of 'CHECK', 'FOREIGN KEY', 'PRIMARY KEY', or 'UNIQUE'.\n 2. The columns on the current table that are constrained, in\n    order.\n 3. For FOREIGN KEY only, the referenced table and columns.\n\n USAGE_SCHEMA is a Struct with fields:\n\n | Field Name               | Field Type              |\n |--------------------------|-------------------------|\n | fk_catalog               | utf8                    |\n | fk_db_schema             | utf8                    |\n | fk_table                 | utf8 not null           |\n | fk_column_name           | utf8 not null           |\n\n This AdbcConnection must outlive the returned ArrowArrayStream.\n\n \\param[in] connection The database connection.\n \\param[in] depth The level of nesting to display. If 0, display\n   all levels. If 1, display only catalogs (i.e.  catalog_schemas\n   will be null). If 2, display only catalogs and schemas\n   (i.e. db_schema_tables will be null), and so on.\n \\param[in] catalog Only show tables in the given catalog. If NULL,\n   do not filter by catalog. If an empty string, only show tables\n   without a catalog.  May be a search pattern (see section\n   documentation).\n \\param[in] db_schema Only show tables in the given database schema. If\n   NULL, do not filter by database schema. If an empty string, only show\n   tables without a database schema. May be a search pattern (see section\n   documentation).\n \\param[in] table_name Only show tables with the given name. If NULL, do not\n   filter by name. May be a search pattern (see section documentation).\n \\param[in] table_type Only show tables matching one of the given table\n   types. If NULL, show tables of any type. Valid table types can be fetched\n   from GetTableTypes.  Terminate the list with a NULL entry.\n \\param[in] column_name Only show columns with the given name. If\n   NULL, do not filter by name.  May be a search pattern (see\n   section documentation).\n \\param[out] out The result set.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcConnectionGetObjects(
        connection: *mut AdbcConnection,
        depth: ::std::os::raw::c_int,
        catalog: *const ::std::os::raw::c_char,
        db_schema: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        table_type: *mut *const ::std::os::raw::c_char,
        column_name: *const ::std::os::raw::c_char,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a string option of the connection.\n\n This must always be thread-safe (other operations are not), though\n given the semantics here, it is not recommended to call GetOption\n concurrently with itself.\n\n length must be provided and must be the size of the buffer pointed\n to by value.  If there is sufficient space, the driver will copy\n the option value (including the null terminator) to buffer and set\n length to the size of the actual value.  If the buffer is too\n small, no data will be written and length will be set to the\n required length.\n\n In other words:\n\n - If output length <= input length, value will contain a value\n   with length bytes.\n - If output length > input length, nothing has been written to\n   value.\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The database connection.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[in,out] length The length of value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcConnectionGetOption(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a bytestring option of the connection.\n\n This must always be thread-safe (other operations are not), though\n given the semantics here, it is not recommended to call\n GetOptionBytes concurrently with itself.\n\n length must be provided and must be the size of the buffer pointed\n to by value.  If there is sufficient space, the driver will copy\n the option value to buffer and set length to the size of the\n actual value.  If the buffer is too small, no data will be written\n and length will be set to the required length.\n\n In other words:\n\n - If output length <= input length, value will contain a value\n   with length bytes.\n - If output length > input length, nothing has been written to\n   value.\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The connection.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[in,out] length The option value length.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcConnectionGetOptionBytes(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *mut u8,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get an integer option of the connection.\n\n This must always be thread-safe (other operations are not).\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The database connection.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcConnectionGetOptionInt(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a double option of the connection.\n\n This must always be thread-safe (other operations are not).\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The database connection.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcConnectionGetOptionDouble(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get statistics about the data distribution of table(s).\n\n The result is an Arrow dataset with the following schema:\n\n | Field Name               | Field Type                       |\n |--------------------------|----------------------------------|\n | catalog_name             | utf8                             |\n | catalog_db_schemas       | list<DB_SCHEMA_SCHEMA> not null  |\n\n DB_SCHEMA_SCHEMA is a Struct with fields:\n\n | Field Name               | Field Type                       |\n |--------------------------|----------------------------------|\n | db_schema_name           | utf8                             |\n | db_schema_statistics     | list<STATISTICS_SCHEMA> not null |\n\n STATISTICS_SCHEMA is a Struct with fields:\n\n | Field Name               | Field Type                       | Comments |\n |--------------------------|----------------------------------| -------- |\n | table_name               | utf8 not null                    |          |\n | column_name              | utf8                             | (1)      |\n | statistic_key            | int16 not null                   | (2)      |\n | statistic_value          | VALUE_SCHEMA not null            |          |\n | statistic_is_approximate | bool not null                    | (3)      |\n\n 1. If null, then the statistic applies to the entire table.\n 2. A dictionary-encoded statistic name (although we do not use the Arrow\n    dictionary type). Values in [0, 1024) are reserved for ADBC.  Other\n    values are for implementation-specific statistics.  For the definitions\n    of predefined statistic types, see \\ref adbc-table-statistics.  To get\n    driver-specific statistic names, use AdbcConnectionGetStatisticNames.\n 3. If true, then the value is approximate or best-effort.\n\n VALUE_SCHEMA is a dense union with members:\n\n | Field Name               | Field Type                       |\n |--------------------------|----------------------------------|\n | int64                    | int64                            |\n | uint64                   | uint64                           |\n | float64                  | float64                          |\n | binary                   | binary                           |\n\n This AdbcConnection must outlive the returned ArrowArrayStream.\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The database connection.\n \\param[in] catalog The catalog (or nullptr).  May be a search\n   pattern (see section documentation).\n \\param[in] db_schema The database schema (or nullptr).  May be a\n   search pattern (see section documentation).\n \\param[in] table_name The table name (or nullptr).  May be a\n   search pattern (see section documentation).\n \\param[in] approximate If zero, request exact values of\n   statistics, else allow for best-effort, approximate, or cached\n   values.  The database may return approximate values regardless,\n   as indicated in the result.  Requesting exact values may be\n   expensive or unsupported.\n \\param[out] out The result set.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcConnectionGetStatistics(
        connection: *mut AdbcConnection,
        catalog: *const ::std::os::raw::c_char,
        db_schema: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        approximate: ::std::os::raw::c_char,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get the names of statistics specific to this driver.\n\n The result is an Arrow dataset with the following schema:\n\n Field Name     | Field Type\n ---------------|----------------\n statistic_name | utf8 not null\n statistic_key  | int16 not null\n\n \\since ADBC API revision 1.1.0\n \\param[in] connection The database connection.\n \\param[out] out The result set.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcConnectionGetStatisticNames(
        connection: *mut AdbcConnection,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get the Arrow schema of a table.\n\n \\param[in] connection The database connection.\n \\param[in] catalog The catalog (or nullptr if not applicable).\n \\param[in] db_schema The database schema (or nullptr if not applicable).\n \\param[in] table_name The table name.\n \\param[out] schema The table schema.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcConnectionGetTableSchema(
        connection: *mut AdbcConnection,
        catalog: *const ::std::os::raw::c_char,
        db_schema: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        schema: *mut ArrowSchema,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a list of table types in the database.\n\n The result is an Arrow dataset with the following schema:\n\n Field Name     | Field Type\n ---------------|--------------\n table_type     | utf8 not null\n\n This AdbcConnection must outlive the returned ArrowArrayStream.\n\n \\param[in] connection The database connection.\n \\param[out] out The result set.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcConnectionGetTableTypes(
        connection: *mut AdbcConnection,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Construct a statement for a partition of a query. The\n   results can then be read independently.\n\n A partition can be retrieved from AdbcPartitions.\n\n This AdbcConnection must outlive the returned ArrowArrayStream.\n\n \\param[in] connection The connection to use.  This does not have\n   to be the same connection that the partition was created on.\n \\param[in] serialized_partition The partition descriptor.\n \\param[in] serialized_length The partition descriptor length.\n \\param[out] out The result set.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcConnectionReadPartition(
        connection: *mut AdbcConnection,
        serialized_partition: *const u8,
        serialized_length: usize,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Commit any pending transactions. Only used if autocommit is\n   disabled.\n\n Behavior is undefined if this is mixed with SQL transaction\n statements."]
    pub fn AdbcConnectionCommit(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Roll back any pending transactions. Only used if autocommit\n   is disabled.\n\n Behavior is undefined if this is mixed with SQL transaction\n statements."]
    pub fn AdbcConnectionRollback(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Create a new statement for a given connection.\n\n Callers pass in a zero-initialized AdbcStatement.\n\n Drivers should allocate their internal data structure and set the private_data\n field to point to the newly allocated struct. This struct should be released\n when AdbcStatementRelease is called."]
    pub fn AdbcStatementNew(
        connection: *mut AdbcConnection,
        statement: *mut AdbcStatement,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Destroy a statement.\n \\param[in] statement The statement to release.\n \\param[out] error An optional location to return an error\n   message if necessary."]
    pub fn AdbcStatementRelease(
        statement: *mut AdbcStatement,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Execute a statement and get the results.\n\n This invalidates any prior result sets.  This AdbcStatement must\n outlive the returned ArrowArrayStream.\n\n Since ADBC 1.1.0: releasing the returned ArrowArrayStream without\n consuming it fully is equivalent to calling AdbcStatementCancel.\n\n \\param[in] statement The statement to execute.\n \\param[out] out The results. Pass NULL if the client does not\n   expect a result set.\n \\param[out] rows_affected The number of rows affected if known,\n   else -1. Pass NULL if the client does not want this information.\n \\param[out] error An optional location to return an error\n   message if necessary."]
    pub fn AdbcStatementExecuteQuery(
        statement: *mut AdbcStatement,
        out: *mut ArrowArrayStream,
        rows_affected: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get the schema of the result set of a query without\n   executing it.\n\n This invalidates any prior result sets.\n\n Depending on the driver, this may require first executing\n AdbcStatementPrepare.\n\n \\since ADBC API revision 1.1.0\n\n \\param[in] statement The statement to execute.\n \\param[out] out The result schema.\n \\param[out] error An optional location to return an error\n   message if necessary.\n\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the driver does not support this."]
    pub fn AdbcStatementExecuteSchema(
        statement: *mut AdbcStatement,
        schema: *mut ArrowSchema,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Turn this statement into a prepared statement to be\n   executed multiple times.\n\n This invalidates any prior result sets."]
    pub fn AdbcStatementPrepare(
        statement: *mut AdbcStatement,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set the SQL query to execute.\n\n The query can then be executed with AdbcStatementExecute.  For\n queries expected to be executed repeatedly, AdbcStatementPrepare\n the statement first.\n\n \\param[in] statement The statement.\n \\param[in] query The query to execute.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcStatementSetSqlQuery(
        statement: *mut AdbcStatement,
        query: *const ::std::os::raw::c_char,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set the Substrait plan to execute.\n\n The query can then be executed with AdbcStatementExecute.  For\n queries expected to be executed repeatedly, AdbcStatementPrepare\n the statement first.\n\n \\param[in] statement The statement.\n \\param[in] plan The serialized substrait.Plan to execute.\n \\param[in] length The length of the serialized plan.\n \\param[out] error Error details, if an error occurs."]
    pub fn AdbcStatementSetSubstraitPlan(
        statement: *mut AdbcStatement,
        plan: *const u8,
        length: usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Bind Arrow data. This can be used for bulk inserts or\n   prepared statements.\n\n \\param[in] statement The statement to bind to.\n \\param[in] values The values to bind. The driver will call the\n   release callback itself, although it may not do this until the\n   statement is released.\n \\param[in] schema The schema of the values to bind.\n \\param[out] error An optional location to return an error message\n   if necessary."]
    pub fn AdbcStatementBind(
        statement: *mut AdbcStatement,
        values: *mut ArrowArray,
        schema: *mut ArrowSchema,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Bind Arrow data. This can be used for bulk inserts or\n   prepared statements.\n \\param[in] statement The statement to bind to.\n \\param[in] stream The values to bind. The driver will call the\n   release callback itself, although it may not do this until the\n   statement is released.\n \\param[out] error An optional location to return an error message\n   if necessary."]
    pub fn AdbcStatementBindStream(
        statement: *mut AdbcStatement,
        stream: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Cancel execution of an in-progress query.\n\n This can be called during AdbcStatementExecuteQuery (or similar),\n or while consuming an ArrowArrayStream returned from such.\n Calling this function should make the other functions return\n ADBC_STATUS_CANCELLED (from ADBC functions) or ECANCELED (from\n methods of ArrowArrayStream).  (It is not guaranteed to, for\n instance, the result set may be buffered in memory already.)\n\n This must always be thread-safe (other operations are not).  It is\n not necessarily signal-safe.\n\n \\since ADBC API revision 1.1.0\n\n \\param[in] statement The statement to cancel.\n \\param[out] error An optional location to return an error\n   message if necessary.\n\n \\return ADBC_STATUS_INVALID_STATE if there is no query to cancel.\n \\return ADBC_STATUS_UNKNOWN if the query could not be cancelled."]
    pub fn AdbcStatementCancel(
        statement: *mut AdbcStatement,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a string option of the statement.\n\n This must always be thread-safe (other operations are not), though\n given the semantics here, it is not recommended to call GetOption\n concurrently with itself.\n\n length must be provided and must be the size of the buffer pointed\n to by value.  If there is sufficient space, the driver will copy\n the option value (including the null terminator) to buffer and set\n length to the size of the actual value.  If the buffer is too\n small, no data will be written and length will be set to the\n required length.\n\n In other words:\n\n - If output length <= input length, value will contain a value\n   with length bytes.\n - If output length > input length, nothing has been written to\n   value.\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] statement The statement.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[in,out] length The length of value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcStatementGetOption(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a bytestring option of the statement.\n\n This must always be thread-safe (other operations are not), though\n given the semantics here, it is not recommended to call\n GetOptionBytes concurrently with itself.\n\n length must be provided and must be the size of the buffer pointed\n to by value.  If there is sufficient space, the driver will copy\n the option value to buffer and set length to the size of the\n actual value.  If the buffer is too small, no data will be written\n and length will be set to the required length.\n\n In other words:\n\n - If output length <= input length, value will contain a value\n   with length bytes.\n - If output length > input length, nothing has been written to\n   value.\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] statement The statement.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[in,out] length The option value length.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcStatementGetOptionBytes(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *mut u8,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get an integer option of the statement.\n\n This must always be thread-safe (other operations are not).\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] statement The statement.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcStatementGetOptionInt(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get a double option of the statement.\n\n This must always be thread-safe (other operations are not).\n\n For standard options, drivers must always support getting the\n option value (if they support getting option values at all) via\n the type specified in the option.  (For example, an option set via\n SetOptionDouble must be retrievable via GetOptionDouble.)  Drivers\n may also support getting a converted option value via other\n getters if needed.  (For example, getting the string\n representation of a double option.)\n\n \\since ADBC API revision 1.1.0\n \\param[in] statement The statement.\n \\param[in] key The option to get.\n \\param[out] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_FOUND if the option is not recognized."]
    pub fn AdbcStatementGetOptionDouble(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Get the schema for bound parameters.\n\n This retrieves an Arrow schema describing the number, names, and\n types of the parameters in a parameterized statement.  The fields\n of the schema should be in order of the ordinal position of the\n parameters; named parameters should appear only once.\n\n If the parameter does not have a name, or the name cannot be\n determined, the name of the corresponding field in the schema will\n be an empty string.  If the type cannot be determined, the type of\n the corresponding field will be NA (NullType).\n\n This should be called after AdbcStatementPrepare.\n\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the schema cannot be determined."]
    pub fn AdbcStatementGetParameterSchema(
        statement: *mut AdbcStatement,
        schema: *mut ArrowSchema,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a string option on a statement.\n \\param[in] statement The statement.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized."]
    pub fn AdbcStatementSetOption(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a bytestring option on a statement.\n\n \\since ADBC API revision 1.1.0\n \\param[in] statement The statement.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[in] length The option value length.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcStatementSetOptionBytes(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *const u8,
        length: usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set an integer option on a statement.\n\n \\since ADBC API revision 1.1.0\n \\param[in] statement The statement.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcStatementSetOptionInt(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Set a double option on a statement.\n\n \\since ADBC API revision 1.1.0\n \\param[in] statement The statement.\n \\param[in] key The option to set.\n \\param[in] value The option value.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized"]
    pub fn AdbcStatementSetOptionDouble(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    #[doc = " \\brief Execute a statement and get the results as a partitioned\n   result set.\n\n \\param[in] statement The statement to execute.\n \\param[out] schema The schema of the result set.\n \\param[out] partitions The result partitions.\n \\param[out] rows_affected The number of rows affected if known,\n   else -1. Pass NULL if the client does not want this information.\n \\param[out] error An optional location to return an error\n   message if necessary.\n \\return ADBC_STATUS_NOT_IMPLEMENTED if the driver does not support\n   partitioned results"]
    pub fn AdbcStatementExecutePartitions(
        statement: *mut AdbcStatement,
        schema: *mut ArrowSchema,
        partitions: *mut AdbcPartitions,
        rows_affected: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
#[doc = " \\brief Common entry point for drivers via the driver manager\n   (which uses dlopen(3)/LoadLibrary). The driver manager is told\n   to load a library and call a function of this type to load the\n   driver.\n\n Although drivers may choose any name for this function, the\n recommended name is \"AdbcDriverInit\", or a name derived from the\n name of the driver's shared library as follows: remove the 'lib'\n prefix (on Unix systems) and all file extensions, then PascalCase\n the driver name, append Init, and prepend Adbc (if not already\n there).  For example:\n\n - libadbc_driver_sqlite.so.2.0.0 -> AdbcDriverSqliteInit\n - adbc_driver_sqlite.dll -> AdbcDriverSqliteInit\n - proprietary_driver.dll -> AdbcProprietaryDriverInit\n\n \\param[in] version The ADBC revision to attempt to initialize (see\n   ADBC_VERSION_1_0_0).\n \\param[out] driver The table of function pointers to\n   initialize. Should be a pointer to the appropriate struct for\n   the given version (see the documentation for the version).\n \\param[out] error An optional location to return an error message\n   if necessary.\n \\return ADBC_STATUS_OK if the driver was initialized, or\n   ADBC_STATUS_NOT_IMPLEMENTED if the version is not supported.  In\n   that case, clients may retry with a different version."]
pub type AdbcDriverInitFunc = ::std::option::Option<
    unsafe extern "C" fn(
        version: ::std::os::raw::c_int,
        driver: *mut ::std::os::raw::c_void,
        error: *mut AdbcError,
    ) -> AdbcStatusCode,
>;
